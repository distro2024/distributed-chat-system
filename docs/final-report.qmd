---
title: "Distributed Chat System"
format: gfm
---

# Distributed Chat Systems - Final Report

**Course:** CSM13001 Distributed Systems, University of Helsinki  
**Members:** Juha Väisänen, Pekka Prökkinen, Ville Hänninen, Heidi Holappa  
**Group number:** 9  

// MAYBE A PICTURE HERE? 

{{< pagebreak >}}

## Table of Contents 
// THIS IS HOW A ToC IS DONE WITH MARKDOWN  
- [Introduction](#introduction) 
- [Techincal overview](#techical-overview)  
  - [Coordinator node](#coordinator-node)  
  - [Node director](#node-director)
  - [Coordinator election](#coordinator-election)  
  - ...
- ...
- [Group participation](#group-participation)  
- [Use of LLMs](#use-of-llms)  

{{< pagebreak >}}

// MAYBE NEW PAGE FOR ALL LEVEL TWO (##) SECTIONS?

## Introduction

```
FROM FINAL REPORT INSTRUCTION:
1. The project’s goal(s) and core functionality. Identifying the applications / services that can build on your project. 
```

The purpose of this project is to research distributed chat systems and to implement a working prototype. As a novel approach, this system does not contain persistent storage. Instead, chat discussions are transient, like phone calls, and remain active only until all nodes leave the communication. At that point, the discussion is gone and cannot be retrieved.

The justification for such an implementation is that in today's world, we all live with an ever-growing digital footprint. At the same time, many of us have a need for private communication. Most social media services maintain communication history, making it difficult to clear previous discussions. This project introduces an approach in which each discussion is transient by default, promoting a new type of real-time, text-based communication.

{{< pagebreak >}}

## Techical overview

```
FROM FINAL REPORT INSTRUCTION:
2. The design principles (architecture, process, communication) techniques.
  - This is typically the main part of the report, because it documents the system design and maps it with the source code
3. What functionalities and how does your system provide? For instance, naming and node discovery, consistency and synchronization, fault tolerance and recovery, etc? For instance, fault tolerance and consensus when a node goes down. 
```


The system under design provides a chat application for end users. When users launch the application to initiate a chat discussion, the client application becomes one of the **chat-nodes** (later nodes) in the distributed chat system. The system includes a **node director** responsible for connecting nodes to each other. In this proof-of-concept version all nodes participate in the same discussion.

Terminology:  
- **node:** chat-node sends and receives messages from other chat-nodes. Chat-node can also serve as a coordinator for other chat-nodes (detailed later in the document)
- **node director:** node director connects new chat-nodes into the group discussion. Node director does not participate in chat discussion, but communicates with the coordinator node (detailed later in the document)

![Basic case](./img/basic_case.png)

### nodes (aka Chat-nodes)

Each node participating in the discussion is a chat-node. Nodes have an identical structure and have an identical state

#### Node state 

Each node stores information of all nodes in the network. For each node, the id of the node and an instance of `socket.io-client` is stored into the object. 

```json
[
    {
        "id": "uuid",
        "address": "io(address)"
    }
]
```

Storing `socket.io-client` to each node helps us streamline the communication, as now we can send a message to all nodes with: 

```javascript
nodes.foreach(nodes) => {
    // check that the node.id is not the id of the sender
    // carry out an operation
    node.address.emit('path', body)
}
```

### Coordinator node

Mechanisms will be in place to handle situations where nodes join or leave the discussion and to resolve any discrepancies in discussion histories among nodes. The team has chosen to implement a coordinator role and an election process initially based on the bully algorithm. The elected coordinator has several duties. It:

- Maintains an up-to-date record of nodes in the discussion.
- Assists new nodes in joining the discussion by providing them with a replica of the current state of the group discussion and the addresses of all nodes in the discussion.
- Keeps in contact with the node director to ensure the node director is aware of the current coordinator node and performs health checks on the node director.  

### Node director
The Node Director has two primary functions: it directs clients to the current coordinator's server and keeps information about the coordinator. When a client connects to the director, they are redirected to the coordinator’s server. To ensure continuity, the coordinator notifies the director of its presence every few seconds, allowing the director to stay up-to-date on the current coordinator. To support these functions, the director provides three endpoints:

`GET /` Redirects the client to the current coordinator's server.  
`POST /register_coordinator` The node director receives the coordinator's ID, internal address and public address.  
`POST /register_node` The node director receives a new node's ID, internal address and public address, then forwards this information to the coordinator.  

{{< pagebreak >}}

### Joining group discussion

When a new node wants to join the chat, it connects first to the Node Director with a known name. The Node Director directs it to a coordinator node, which gives two neighbour nodes to exchange messages with. Now the new node is ready for multicasting new messages to its neighbours and to receive messages from them.

```{mermaid}
flowchart TD
    A[Node X] --> |wants to join the chat, calls to Node Director| B[Node Director]
    B --> |directs the new node to Coordinator node| C[Coordinator node]
    C --> |gives neighbours to NodeX| D[Now Node X is a part of the chat]
```

{{< pagebreak >}}

### Coordinator election

> This subsection contains references to the prototype module ./node/election.js. Each referenced method can be found in this module. 

The first node to join the network will be automatically made the Coordinator. After this, every Coordinator is decided with an election process. The prototype implements an election process based on the well established Bully-algorithm (Garcia-Molina 1982). 

In this implementation all other nodes send a heartbeat to the Coordinator node at pseudo-randomized interval between $[T, 2T]$ seconds. When a node does not receive a reponse to two consecutive heartbeats, it initiates an election by sending an election message to all nodes with an id higher than its id. In the prototype ids are UUIDs and the comparison is an ascending String comparison (i.e. $(aaaa < aaab < aabb < \ldots)$). For implementation see method `initiateElection`. 

After initiating the election, the node waits for a specified time (in the prototype three seconds) for responses. 
- If no responses arrive, it announces itself as a Coordinator. 
- If a response from a higher Id node arrived, it denounces its candidacy (module-scoped global variable `isCandidate` is set to false). 

Upon receiving an election request, all nodes initiate their own elections. The idea, as in Bully algorithm, is that the node with the highest id is the only one that should not receive any responses, given that the assumptions set by Garcia-Molina hold (1982). That is, for instance, that no messages are lost during election. 




### Sending and receiving messages

The nodes will send chat messages to all other nodes in the group discussion. The team will investigate a mechanism for transferring chat messages to each other efficiently. The idea is to simulate multicast functionality that works also when the nodes are in different networks. As a starting point, the team investigates using websockets or HTTP/2-protocol for inter-node communication. As communication between nodes is direct node-to-node discussion, no middleware is required in this proof-of-concept phase.  

The team has outlined the necessary messages for the system currently under design. While the communication technology and protocol are still being evaluated, the final format of these messages has not yet been determined. For clarity and readability, the proposed message content is presented in JSON format. Regardless of the chosen technology, these examples will illustrate the intended structure and content.

#### Chat messages  

Any node (i.e. chat-node) can send chat-messages to other nodes: POST `/message`
```json
{ 
    "id": "uuid",
    "node-id": "uuid",
    "timestamp": "timestamp",
    "message": "string"
    "vector-clock:" ["int"]
}
```

#### Election process  

Messages related to the election process with Bully-algorithm:


Any node can initiate election process by sending a request to nodes with higher priority: POST `/election`
```json
{
    "node-id": "uuid"
}
```

Higher priority nodes respond with an OK: POST `/vote`
```json
{
    "ok": "uuid"
}
```
{{< pagebreak >}}

Once one of the nodes has bullied other into submission, they notify other nodes that they are the new coordinator: POST `/update-coordinator`
```json
{
    "coodinator": "uuid"
}
```


#### Communication with coordinator node  

The coordinator node can send a message requesting other nodes to update the record of actives nodes in group discussion after nodes join or leave the discussion: POST `/nodes`
```json
{
    "node": ["uuid"]
}
```

Any node can get the discussion history from coordinator node: GET `/discussion`

The coordinator then responds with the discussion history (a list of message objects): POST `/discussion`

```json
{
    "messages": [
        { 
            "id": "uuid",
            "node-id": "uuid",
            "timestamp": "timestamp",
            "message": "string"
            "vector-clock:" ["int"]
        }
    ] 
}
```

### Eventual Consistency in discussion 

* **Direct Communication:** Nodes communicate directly with each other, reducing reliance on a single point of failure.

* **Vector Clocks, Timestamps, and Priority Queue:** 
    - Each node tracks events using a vector clock, with counters representing the state of each node.
    - The local counter is **incremented only when the node sends a message**, accurately reflecting local events.
    - Upon receiving a message, the local vector clock is updated by merging with the incoming clock, taking the maximum value for each node. 
    - **Timestamps are used to break ties when vector clocks are identical.** 
    - **A priority queue (implemented through the `discussion` array) stores messages, ordered by their vector clocks and timestamps.**  This queue uses the `compareMessages` function to determine the order of messages during insertion.
        - **Inserting a new message into this queue has a time complexity of O(n) in the worst case**, where n is the number of messages in the queue. This is because the `handleNewMessage` function (which utilizes the `compareMessages` function) potentially needs to iterate through the entire array to find the correct position for the new message.
        - **Retrieving messages from the queue (when sending the history to clients or new nodes) has a time complexity of O(1)** since the messages are already stored in order.

* **Catch-up Mechanism:** New nodes receive the full chat history (`discussion` array), allowing them to become consistent with the rest of the network.

* **Points to consider for future development:**
    - **Vector Clock size**: Vector clocks grow in size as the number of nodes increases. This can lead to increased storage and communication overhead. Consider strategies to manage clock size, such as pruning old entries.
    - **Catch-up Optimization**: Sending the entire discussion array to new nodes can be inefficient if the chat history is very large. Consider optimizing the catch-up mechanism, perhaps by sending only a recent portion of the history.

{{< pagebreak >}}

### Language selection

The chat nodes and the node director will be implemented using Node.js. Node.js has a strong reputation in handling asynchronous calls, which the team considers to be a critical functionality for the system under design. 

### No persistent storage

As the motivation is to built a system for group discussions without any persistent memory, no database is necessary for this proof-of-concept. Once all client applications shut down, the discussion is lost forever.

### Container technology

All nodes will reside within containers, which may or may not be located on the same physical machine. This containerized approach ensures flexibility, scalability, and ease of deployment across different environments.

{{< pagebreak >}}

## From prototype to MVP

```
FINAL REPORT INSTRUCTION
4. How do you show that your system can scale to support the increased number of nodes?
5. How do you quantify the performance of the system and what did you do (can do) to improve the performance of the system (for instance reduce the latency or improve the throughput)?
6. The key enablers and the lessons learned during the development of the project.
7. Notes about the group members and their participation, work task division, etc. Here you also may report, if you feel that the points collected to group should be split unevenly among group members. Use percentages when descripting this balancing view point. 
```


## Lessons learned

```
FINAL REPORT INSTRUCTION
6. The key enablers and the lessons learned during the development of the project.
```

During the first two weeks of the project, the team has concentrated on research and planning. They have designed a preliminary architecture for the implementation and selected the technologies to be used. With these foundational steps completed, the project is now poised to enter the development phase. 

However, some critical details still need to be finalized. Specifically, the technical aspects of inter-node communication and synchronization are yet to be determined. These topics will be addressed in the lectures during weeks 3 and 4, after which the necessary design decisions will be made.

In the meantime, the team can proceed by developing the chat nodes and the node director. This phased approach allows for continuous progress while awaiting further clarification on the remaining technical issues.

{{< pagebreak >}}

## Group participation

```
FINAL REPORT INSTRUCTION
7. Notes about the group members and their participation, work task division, etc. Here you also may report, if you feel that the points collected to group should be split unevenly among group members. Use percentages when descripting this balancing view point. 
```

- How did everyone participate
- How did we work
  - meetings
  - how we kept in touch
  - pair coding etc. 

The team maintains active communication through a group discussion on Telegram. Each weekend, they hold an online call to plan the upcoming week and discuss any current issues. Work items are coordinated using a Kanban-style project board on GitHub, where tasks are tracked as issues. This approach helps the team better estimate workloads, coordinate active tasks, and plan the project's timeline effectively.

{{< pagebreak >}}

## Use of LLMs 

University of Helsinki Large Language Model Curre, Microsoft Co-pilot and Chat-GPT have been used to help improve the grammar of the documentation and to polish the text. Separate LLMs have been prompted to provide feedback on text and to suggest improvements. The response has then been evaualuated and with consideration applied to improve the text. 


{{< pagebreak >}}

## References

Garcia-Molina H. 1982. Elections in a Distributed Computing System. IEEE Transactions on Computers, 31(1):48–59, Jan. 1982.

Steen, M. van & Tanenbaum, A. S. 2024. Distributed systems / Maarten van Steen, Andrew S. Tanenbaum. Fourth edition, Version 4.02 (2022). Published at unknown.